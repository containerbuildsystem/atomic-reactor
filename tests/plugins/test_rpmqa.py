"""
Copyright (c) 2015-2022 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.
"""
import functools
import subprocess
import tarfile
from pathlib import Path
from tempfile import _RandomNameSequence

import docker
import pytest
from flexmock import flexmock

from atomic_reactor.plugin import PostBuildPluginsRunner, PluginFailedException
from atomic_reactor.plugins.post_rpmqa import (PostBuildRPMqaPlugin, RPMDB_DIR_NAME, RPMDB_PATH)
from atomic_reactor.util import DockerfileImages
from atomic_reactor.utils import retries
from atomic_reactor.utils.rpm import parse_rpm_output

TEST_IMAGE = "fedora:latest"

PACKAGE_LIST = ['python-docker-py;1.3.1;1.fc24;noarch;(none);'
                '191456;7c1f60d8cde73e97a45e0c489f4a3b26;1438058212;(none);(none);(none);(none)',
                'fedora-repos-rawhide;24;0.1;noarch;(none);'
                '2149;d41df1e059544d906363605d47477e60;1436940126;(none);(none);(none);(none)',
                'gpg-pubkey-doc;1.0;1;noarch;(none);'
                '1000;00000000000000000000000000000000;1436940126;(none);(none);(none);(none)']
PACKAGE_LIST_WITH_AUTOGENERATED = PACKAGE_LIST + ['gpg-pubkey;qwe123;zxcasd123;(none);(none);0;'
                                                  '(none);1370645731;(none);(none)']
PACKAGE_LIST_WITH_AUTOGENERATED_B = [x.encode("utf-8") for x in PACKAGE_LIST_WITH_AUTOGENERATED]

pytestmark = pytest.mark.usefixtures('user_params')


def mock_oc_image_extract(cmd, rpm_dir_exists=True, rpm_dir_empty=False):
    """Mock `oc image extract`
    :param str cmd: `oc image extract` command list for calling `run_cmd`
    :param bool rpm_dir_exists: whether the archive contains rpm db directory.
    :param bool rpm_dir_empty: whether the rpm db directory in archive is empty.
    :rtype: generator
    """
    rpm_dir = Path(cmd[-1].split(':')[-1])
    archive_path = rpm_dir / 'temp.tar'
    if rpm_dir_exists:
        rpm_dir = rpm_dir / RPMDB_DIR_NAME
        rpm_dir.mkdir()
        if not rpm_dir_empty:
            rpm_dir.joinpath('Basenames').touch()
            rpm_dir.joinpath('Dirnames').touch()
            rpm_dir.joinpath('Packages').touch()

        with tarfile.open(str(archive_path), 'w') as archive_tar:
            archive_tar.add(str(rpm_dir), arcname=RPMDB_DIR_NAME)
    else:
        non_rpm_dir = rpm_dir / 'non_rpm_dir'
        non_rpm_dir.mkdir()
        with tarfile.open(archive_path, 'w') as archive_tar:
            archive_tar.add(str(non_rpm_dir), arcname='non_rpm_dir')

    archive_path.unlink()


def mock_logs(cid, **kwargs):
    return b"\n".join(PACKAGE_LIST_WITH_AUTOGENERATED_B)


def mock_logs_raise(cid, **kwargs):
    raise RuntimeError


def mock_logs_empty(cid, **kwargs):
    return ''


def setup_mock_logs_retry(cache=None):
    cache = cache or {}
    cache.setdefault('attempt', 0)

    def mock_logs_retry(cid, **kwargs):
        if cache['attempt'] < 4:
            logs = mock_logs_empty(cid, **kwargs)
        else:
            logs = mock_logs(cid, **kwargs)

        cache['attempt'] += 1
        return logs

    return mock_logs_retry


def set_df_images(workflow, base_from_scratch=False):
    if base_from_scratch:
        workflow.data.dockerfile_images = DockerfileImages(['scratch'])
    else:
        workflow.data.dockerfile_images = DockerfileImages([])


@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
@pytest.mark.parametrize("ignore_autogenerated", [
    {"ignore": True, "package_list": PACKAGE_LIST},
    {"ignore": False, "package_list": PACKAGE_LIST_WITH_AUTOGENERATED},
])
def test_rpmqa_plugin_success(caplog, workflow, build_dir, base_from_scratch,
                              ignore_autogenerated):
    platforms = ['x86_64', 's390x', 'ppc64le', 'aarch64']

    workflow.build_dir.init_build_dirs(platforms, workflow.source)
    workflow.data.tag_conf.add_unique_image(f'registry.com/{TEST_IMAGE}')
    set_df_images(workflow, base_from_scratch=base_from_scratch)

    (flexmock(retries)
     .should_receive("run_cmd")
     .replace_with(mock_oc_image_extract))

    (flexmock(_RandomNameSequence)
     .should_receive("__next__")
     .times(4)
     .and_return('abcdef12'))

    (flexmock(subprocess)
     .should_receive("check_output")
     .times(4)
     .and_return("\n".join(PACKAGE_LIST_WITH_AUTOGENERATED)))

    flexmock(docker.APIClient, logs=mock_logs)
    runner = PostBuildPluginsRunner(
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              "ignore_autogenerated_gpg_keys": ignore_autogenerated["ignore"]}}
         ])
    results = runner.run()

    for platform in platforms:
        assert results[PostBuildRPMqaPlugin.key][platform] == parse_rpm_output(ignore_autogenerated[
                                                                                   "package_list"])


@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
def test_rpmqa_plugin_rpm_query_failed(caplog, workflow, build_dir, base_from_scratch):
    platforms = ['x86_64', 's390x', 'ppc64le', 'aarch64']

    workflow.data.tag_conf.add_unique_image(f'registry.com/{TEST_IMAGE}')

    workflow.build_dir.init_build_dirs(platforms, workflow.source)
    set_df_images(workflow, base_from_scratch=base_from_scratch)

    (flexmock(retries)
     .should_receive("run_cmd")
     .replace_with(mock_oc_image_extract))

    runner = PostBuildPluginsRunner(
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              "ignore_autogenerated_gpg_keys": True}}
         ])

    log_msg_getting = 'getting rpms from rpmdb:'

    (flexmock(subprocess)
     .should_receive("check_output")
     .once()
     .and_raise(Exception, 'rpm query failed'))

    with pytest.raises(Exception, match='rpm query failed'):
        runner.run()
    assert log_msg_getting in caplog.text
    log_msg = 'Failed to get rpms from rpmdb:'
    assert log_msg in caplog.text


@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
def test_rpmqa_plugin_rpmdb_dir_is_empty(caplog, workflow, build_dir, base_from_scratch):
    platforms = ['x86_64', 's390x', 'ppc64le', 'aarch64']

    workflow.data.tag_conf.add_unique_image(f'registry.com/{TEST_IMAGE}')

    mock_oc_image_extract_empty_dir = functools.partial(mock_oc_image_extract, rpm_dir_empty=True)

    (flexmock(retries)
     .should_receive("run_cmd")
     .replace_with(mock_oc_image_extract_empty_dir))

    workflow.build_dir.init_build_dirs(platforms, workflow.source)
    set_df_images(workflow, base_from_scratch=base_from_scratch)

    runner = PostBuildPluginsRunner(
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              "ignore_autogenerated_gpg_keys": True}}
         ])

    log_msg = f'rpmdb directory {RPMDB_PATH} is empty'
    if base_from_scratch:
        results = runner.run()
        assert log_msg in caplog.text
        for platform in platforms:
            assert results[PostBuildRPMqaPlugin.key][platform] is None
    else:
        with pytest.raises(PluginFailedException, match=log_msg):
            runner.run()
        assert log_msg in caplog.text


def test_rpmqa_plugin_exception(workflow):
    platforms = ['x86_64', 's390x', 'ppc64le', 'aarch64']

    workflow.build_dir.init_build_dirs(platforms, workflow.source)
    set_df_images(workflow)

    runner = PostBuildPluginsRunner(workflow,
                                    [{"name": PostBuildRPMqaPlugin.key,
                                      "args": {}}])
    with pytest.raises(PluginFailedException):
        runner.run()
