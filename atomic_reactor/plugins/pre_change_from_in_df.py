"""
Copyright (c) 2015-2022 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.


Pre-build plugin that changes the parent images used in FROM instructions
to the more specific names given by the builder.
"""
from atomic_reactor.plugin import PreBuildPlugin
from atomic_reactor.util import df_parser, base_image_is_scratch


class BaseImageMismatch(RuntimeError):
    pass


class ParentImageUnresolved(RuntimeError):
    pass


class ParentImageMissing(RuntimeError):
    pass


class ChangeFromPlugin(PreBuildPlugin):
    key = "change_from_in_dockerfile"
    is_allowed_to_fail = False

    def __init__(self, workflow):
        """
        constructor

        :param workflow: DockerBuildWorkflow instance
        """
        # call parent constructor
        super(ChangeFromPlugin, self).__init__(workflow)

    def _sanity_check(self, df_base, builder_base):
        image = self.workflow.data.dockerfile_images[df_base]
        if builder_base != image:
            # something updated parent_images entry for base without updating
            # the build's base_image; treat it as an error
            raise BaseImageMismatch(
                "Parent image '{}' for df_base {} does not match base_image '{}'"
                .format(image, df_base, builder_base)
            )

    def run(self):
        dfp = df_parser(self.workflow.df_path)
        df_base = dfp.baseimage

        df_images = self.workflow.data.dockerfile_images
        build_base = df_images.base_image

        if not df_images.base_from_scratch:
            # do some sanity checks to defend against bugs and rogue plugins
            self._sanity_check(dfp.baseimage, build_base)

        self.log.info("parent_images '%s'", df_images.keys())
        unresolved = [key for key, val in df_images.items() if not val]
        if unresolved:
            # this would generally mean check_base_image didn't run and/or
            # custom plugins modified parent_images; treat it as an error.
            raise ParentImageUnresolved("Parent image(s) unresolved: {}".format(unresolved))

        # check for lost parent images
        missing_set = set()
        for df_img in dfp.parent_images:
            if base_image_is_scratch(df_img):
                continue
            try:
                df_images[df_img]
            except KeyError:
                missing_set.add(df_img)
        if missing_set:
            # this would indicate another plugin modified parent_images out of sync
            # with the Dockerfile or some other code bug
            raise ParentImageMissing(f"Lost parent image(s) from Dockerfile images and their "
                                     f"parents:"
                                     f" {missing_set}")

        # replace image tags with manifest digests generated by check_base_image
        new_parents = []

        for df_img in dfp.parent_images:
            if base_image_is_scratch(df_img):
                new_parents.append(df_img)
            else:
                new_parents.append(df_images[df_img].to_str())

        # update parent_images in Dockerfile
        dfp.parent_images = new_parents

        if df_images.base_from_scratch:
            return

        self.log.debug(
            "for base image '%s' using image with pullspec '%s'",
            df_base, build_base
        )
